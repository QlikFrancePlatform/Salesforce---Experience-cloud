<apex:page controller="QlikPageController" showHeader="false" sidebar="false" standardStylesheets="false" applyBodyTag="false" applyHtmlTag="false" docType="html">
    <html>

    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Qlik Embed Enigma D3.js - Indicateurs</title>

        <!-- Include Salesforce Lightning Design System -->
        <apex:slds/>

        <!-- Include Qlik Embed Web Components Script for authentication -->
        <script type="text/javascript">
            // Prevent WebAuthn conflicts by temporarily disabling the API
            const originalCredentials = window.navigator.credentials;
            if (originalCredentials) {
                Object.defineProperty(navigator, 'credentials', {
                    value: undefined,
                    writable: true,
                    configurable: true
                });
            }
        </script>


        <!-- Include enigma.js library -->
        <script src="https://unpkg.com/enigma.js@2.7.3/enigma.min.js"></script>
        
        <!-- Include D3.js library for bar chart -->
        <script src="https://d3js.org/d3.v7.min.js"></script>
        
        <script type="text/javascript">
            // Initialize D3.js ready flag
            window.d3Ready = typeof d3 !== 'undefined';
            
            // Wait for D3.js to be fully loaded
            if (!window.d3Ready) {
                const checkD3 = setInterval(() => {
                    if (typeof d3 !== 'undefined') {
                        window.d3Ready = true;
                        clearInterval(checkD3);
                        console.log('D3.js loaded successfully');
                    }
                }, 100);
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    clearInterval(checkD3);
                    if (!window.d3Ready) {
                        console.error('D3.js failed to load');
                    }
                }, 10000);
            }
        </script>

        <script type="text/javascript">
            // Restore WebAuthn API after Qlik script loads
            if (typeof originalCredentials !== 'undefined' && originalCredentials) {
                Object.defineProperty(navigator, 'credentials', {
                    value: originalCredentials,
                    writable: true,
                    configurable: true
                });
            }

            // Configuration Qlik Cloud inspirée de l'article community
            // https://community.qlik.com/t5/Design/Interacting-with-data-using-Enigma-js-PT-3-Evaluate-amp-Monitor/ba-p/2082377
            // Configuration loaded from Custom Metadata Types
            const QLIK_CLOUD_CONFIG = {
                tenant: '{!qlikTenant}',
                webIntegrationId: '{!qlikWebIntegrationId}',
                appId: '{!qlikDefaultAppId}',
                objectIds: ['htaMkv', 'YGN', 'mrdwGJ', 'pwGchT'],
                identity: 'SalesforcePortal'
            };

            async function qlikLogin() {
                const response = await fetch(`https://${QLIK_CLOUD_CONFIG.tenant}/api/v1/users/me`, {
                    mode: 'cors',
                    credentials: 'include',
                    headers: {
                        'qlik-web-integration-id': QLIK_CLOUD_CONFIG.webIntegrationId
                    }
                });

                if (response.status === 200) {
                    sessionStorage.removeItem('tryQlikAuth');
                    return true;
                }

                if (!sessionStorage.getItem('tryQlikAuth')) {
                    sessionStorage.setItem('tryQlikAuth', '1');
                    const loginUrl = `https://${QLIK_CLOUD_CONFIG.tenant}/login?qlik-web-integration-id=${QLIK_CLOUD_CONFIG.webIntegrationId}&returnto=${encodeURIComponent(window.location.href)}`;
                    window.location.href = loginUrl;
                    await new Promise(resolve => setTimeout(resolve, 10000));
                } else {
                    sessionStorage.removeItem('tryQlikAuth');
                    throw new Error('Connexion Qlik Cloud impossible (cookies tiers ?).');
                }
                return false;
            }

            async function getQCSHeaders() {
                const response = await fetch(`https://${QLIK_CLOUD_CONFIG.tenant}/api/v1/csrf-token`, {
                    mode: 'cors',
                    credentials: 'include',
                    headers: {
                        'qlik-web-integration-id': QLIK_CLOUD_CONFIG.webIntegrationId
                    }
                });

                if (!response.ok) {
                    throw new Error(`Impossible de récupérer le token CSRF (${response.status}).`);
                }

                const csrfToken = response.headers.get('qlik-csrf-token');
                if (!csrfToken) {
                    throw new Error('Token CSRF manquant dans la réponse Qlik Cloud.');
                }

                return {
                    'qlik-web-integration-id': QLIK_CLOUD_CONFIG.webIntegrationId,
                    'qlik-csrf-token': csrfToken
                };
            }

            // Fonction pour mettre à jour le statut
            function updateStatus(message, isError = false) {
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.className = isError 
                        ? 'slds-text-body_regular slds-text-color_error' 
                        : 'slds-text-body_regular slds-text-color_success';
                }
            }

            // Fonction pour afficher un indicateur
            function displayIndicator(containerId, data, objectId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                try {
                    // Extraire les données du layout
                    const layout = data.qLayout || data;
                    const qMeta = layout.qMeta || {};
                    const title = qMeta.title || `Objet ${objectId}`;
                    
                    // Essayer différents types d'objets Qlik
                    let displayData = null;
                    
                    // 1. KPI (qkpi)
                    if (layout.qkpi) {
                        const kpi = layout.qkpi;
                        displayData = {
                            type: 'kpi',
                            value: kpi.qValue?.qText || kpi.qValue?.qNum || 'N/A',
                            label: title
                        };
                    }
                    // 2. HyperCube (graphiques, tableaux)
                    else if (layout.qHyperCube) {
                        const hyperCube = layout.qHyperCube;
                        if (hyperCube.qDataPages && hyperCube.qDataPages[0]) {
                            const matrix = hyperCube.qDataPages[0].qMatrix;
                            if (matrix && matrix.length > 0) {
                                // Pour un KPI simple, prendre la première valeur
                                if (matrix.length === 1 && matrix[0].length === 1) {
                                    displayData = {
                                        type: 'kpi',
                                        value: matrix[0][0]?.qText || matrix[0][0]?.qNum || 'N/A',
                                        label: title
                                    };
                                } else {
                                    // Pour un tableau, afficher les premières lignes
                                    displayData = {
                                        type: 'table',
                                        data: matrix.slice(0, 10), // Limiter à 10 lignes
                                        label: title
                                    };
                                }
                            }
                        }
                    }
                    // 3. ListObject (listes de valeurs)
                    else if (layout.qListObject) {
                        const listObject = layout.qListObject;
                        if (listObject.qDataPages && listObject.qDataPages[0]) {
                            const matrix = listObject.qDataPages[0].qMatrix;
                            if (matrix && matrix.length > 0) {
                                displayData = {
                                    type: 'list',
                                    data: matrix.slice(0, 10),
                                    label: title
                                };
                            }
                        }
                    }
                    
                    // Afficher les données
                    if (displayData) {
                        if (displayData.type === 'kpi') {
                            container.innerHTML = `
                                <div class="slds-card">
                                    <div class="slds-card__header slds-grid">
                                        <header class="slds-media slds-media_center slds-has-flexi-truncate">
                                            <div class="slds-media__body">
                                                <h2 class="slds-card__header-title">
                                                    <span>${displayData.label}</span>
                                                </h2>
                                            </div>
                                        </header>
                                    </div>
                                    <div class="slds-card__body slds-card__body_inner">
                                        <div class="slds-text-heading_large slds-text-align_center" style="padding: 20px;">
                                            ${displayData.value}
                                        </div>
                                    </div>
                                </div>
                            `;
                        } else {
                            // Afficher un tableau pour les données complexes
                            let tableRows = '';
                            displayData.data.forEach(row => {
                                const cells = row.map(cell => 
                                    `<td class="slds-cell-wrap">${cell?.qText || cell?.qNum || ''}</td>`
                                ).join('');
                                tableRows += `<tr>${cells}</tr>`;
                            });
                            
                            container.innerHTML = `
                                <div class="slds-card">
                                    <div class="slds-card__header slds-grid">
                                        <header class="slds-media slds-media_center slds-has-flexi-truncate">
                                            <div class="slds-media__body">
                                                <h2 class="slds-card__header-title">
                                                    <span>${displayData.label}</span>
                                                </h2>
                                            </div>
                                        </header>
                                    </div>
                                    <div class="slds-card__body slds-card__body_inner">
                                        <table class="slds-table slds-table_cell-buffer slds-table_bordered">
                                            <tbody>
                                                ${tableRows}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            `;
                        }
                    } else {
                        container.innerHTML = `
                            <div class="slds-card">
                                <div class="slds-card__body slds-card__body_inner">
                                    <div class="slds-text-body_regular">
                                        Aucune donnée disponible pour ${title}
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Error displaying indicator:', error);
                    container.innerHTML = `<div class="slds-text-color_error">Erreur d'affichage: ${error.message}</div>`;
                }
            }

            function prepareIndicatorContainers(count) {
                const container = document.getElementById('indicators-container');
                if (!container) {
                    return [];
                }
                const ids = [];
                container.innerHTML = '';
                for (let i = 0; i < count; i++) {
                    const indicator = document.createElement('div');
                    indicator.id = `indicator-${i}`;
                    indicator.className = 'indicator-container';
                    // Pour les graphiques D3, ajouter une classe spéciale et une hauteur minimale
                    if (QLIK_CLOUD_CONFIG.objectIds[i] === 'mrdwGJ') {
                        indicator.className += ' d3-chart-container';
                        indicator.style.minHeight = '400px';
                        indicator.style.width = '100%';
                    }
                    container.appendChild(indicator);
                    ids.push(indicator.id);
                }
                return ids;
            }

            // Fonction pour attendre que D3.js soit chargé
            async function waitForD3() {
                let attempts = 0;
                const maxAttempts = 50; // 5 secondes max
                while (attempts < maxAttempts) {
                    if (typeof d3 !== 'undefined' && window.d3Ready) {
                        console.log('D3.js is ready!');
                        return true;
                    }
                    
                    if (attempts % 10 === 0) {
                        console.log(`Waiting for D3.js... (attempt ${attempts}/${maxAttempts})`);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (typeof d3 !== 'undefined') {
                    window.d3Ready = true;
                    return true;
                }
                
                throw new Error('D3.js library failed to load. Please check your network connection and browser console.');
            }

            // Fonction pour extraire les données d'un HyperCube pour D3.js
            function extractHyperCubeData(hyperCube) {
                const data = [];
                if (hyperCube && hyperCube.qDataPages && hyperCube.qDataPages[0]) {
                    const matrix = hyperCube.qDataPages[0].qMatrix;
                    const dimensions = hyperCube.qDimensionInfo || [];
                    const measures = hyperCube.qMeasureInfo || [];
                    
                    if (matrix && matrix.length > 0) {
                        matrix.forEach((row, rowIndex) => {
                            const item = {};
                            
                            // Extraire les dimensions (labels)
                            dimensions.forEach((dim, dimIndex) => {
                                if (row[dimIndex]) {
                                    item[dim.qFallbackTitle || `Dimension${dimIndex}`] = row[dimIndex].qText || row[dimIndex].qNum;
                                }
                            });
                            
                            // Extraire les mesures (valeurs)
                            measures.forEach((measure, measureIndex) => {
                                const valueIndex = dimensions.length + measureIndex;
                                if (row[valueIndex]) {
                                    item[measure.qFallbackTitle || `Measure${measureIndex}`] = parseFloat(row[valueIndex].qText || row[valueIndex].qNum) || 0;
                                }
                            });
                            
                            data.push(item);
                        });
                    }
                }
                return data;
            }

            // Fonction pour afficher un graphique en barre avec D3.js
            async function displayD3BarChart(containerId, app, objectId) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error(`Container ${containerId} not found`);
                    return;
                }

                try {
                    // Attendre que D3.js soit chargé
                    await waitForD3();

                    // Obtenir l'objet Qlik
                    const obj = await app.getObject(objectId);
                    const layout = await obj.getLayout();
                    
                    // Extraire les données du HyperCube
                    const hyperCube = layout.qHyperCube;
                    if (!hyperCube) {
                        throw new Error('L\'objet ne contient pas de HyperCube');
                    }
                    
                    let chartData = extractHyperCubeData(hyperCube);
                    if (chartData.length === 0) {
                        throw new Error('Aucune donnée disponible dans l\'objet');
                    }

                    // Limiter à 100 produits maximum
                    const maxProducts = 100;
                    if (chartData.length > maxProducts) {
                        chartData = chartData.slice(0, maxProducts);
                        console.log(`Données limitées à ${maxProducts} produits (${extractHyperCubeData(hyperCube).length} au total)`);
                    }

                    // Créer un conteneur pour le graphique
                    const title = layout.qMeta?.title || `Graphique en barres - ${objectId}`;
                    container.innerHTML = `
                        <div class="slds-card">
                            <div class="slds-card__header slds-grid">
                                <header class="slds-media slds-media_center slds-has-flexi-truncate">
                                    <div class="slds-media__body">
                                        <h2 class="slds-card__header-title">
                                            <span>${title}</span>
                                        </h2>
                                    </div>
                                </header>
                            </div>
                            <div class="slds-card__body slds-card__body_inner" style="padding: 20px;">
                                <div id="d3-chart-${objectId}" style="width: 100%; height: 400px;"></div>
                            </div>
                        </div>
                    `;

                    const chartContainer = document.getElementById(`d3-chart-${objectId}`);
                    if (!chartContainer) {
                        throw new Error('Chart container not created');
                    }

                    // Préparer les données pour D3.js
                    // Prendre la première dimension comme label et la première mesure comme valeur
                    const dimensionKey = Object.keys(chartData[0]).find(k => !k.startsWith('Measure')) || Object.keys(chartData[0])[0];
                    const measureKey = Object.keys(chartData[0]).find(k => k.startsWith('Measure')) || Object.keys(chartData[0])[Object.keys(chartData[0]).length - 1];
                    
                    const data = chartData.map(d => ({
                        label: d[dimensionKey] || 'N/A',
                        value: d[measureKey] || 0
                    }));

                    // Créer le graphique en barres avec D3.js
                    const margin = { top: 20, right: 30, bottom: 60, left: 60 };
                    const width = chartContainer.clientWidth - margin.left - margin.right;
                    const height = 400 - margin.top - margin.bottom;

                    // Nettoyer le conteneur
                    d3.select(chartContainer).selectAll('*').remove();

                    // Créer le SVG
                    const svg = d3.select(chartContainer)
                        .append('svg')
                        .attr('width', width + margin.left + margin.right)
                        .attr('height', height + margin.top + margin.bottom);

                    const g = svg.append('g')
                        .attr('transform', `translate(${margin.left},${margin.top})`);

                    // Échelles
                    const xScale = d3.scaleBand()
                        .range([0, width])
                        .padding(0.2)
                        .domain(data.map(d => d.label));

                    const yScale = d3.scaleLinear()
                        .range([height, 0])
                        .domain([0, d3.max(data, d => d.value)]);

                    // Axes
                    g.append('g')
                        .attr('transform', `translate(0,${height})`)
                        .call(d3.axisBottom(xScale))
                        .selectAll('text')
                        .attr('transform', 'rotate(-45)')
                        .style('text-anchor', 'end')
                        .style('font-size', '12px');

                    g.append('g')
                        .call(d3.axisLeft(yScale))
                        .style('font-size', '12px');

                    // Barres
                    g.selectAll('.bar')
                        .data(data)
                        .enter()
                        .append('rect')
                        .attr('class', 'bar')
                        .attr('x', d => xScale(d.label))
                        .attr('y', d => yScale(d.value))
                        .attr('width', xScale.bandwidth())
                        .attr('height', d => height - yScale(d.value))
                        .attr('fill', '#0176d3')
                        .on('mouseover', function(event, d) {
                            d3.select(this).attr('fill', '#014486');
                        })
                        .on('mouseout', function() {
                            d3.select(this).attr('fill', '#0176d3');
                        });

                    // Labels sur les barres
                    g.selectAll('.bar-label')
                        .data(data)
                        .enter()
                        .append('text')
                        .attr('class', 'bar-label')
                        .attr('x', d => xScale(d.label) + xScale.bandwidth() / 2)
                        .attr('y', d => yScale(d.value) - 5)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '11px')
                        .style('fill', '#333')
                        .text(d => d.value.toLocaleString());

                    // Stocker la référence pour la mise à jour
                    window[`d3Chart_${objectId}`] = { obj, chartContainer, data, svg, g, xScale, yScale };

                    // Écouter les changements
                    obj.on('changed', async () => {
                        const updatedLayout = await obj.getLayout();
                        const updatedHyperCube = updatedLayout.qHyperCube;
                        let updatedData = extractHyperCubeData(updatedHyperCube);
                        
                        // Limiter à 100 produits maximum
                        const maxProducts = 100;
                        if (updatedData.length > maxProducts) {
                            updatedData = updatedData.slice(0, maxProducts);
                        }
                        
                        if (updatedData.length > 0) {
                            const newData = updatedData.map(d => ({
                                label: d[dimensionKey] || 'N/A',
                                value: d[measureKey] || 0
                            }));
                            
                            // Mettre à jour le graphique
                            updateD3BarChart(`d3-chart-${objectId}`, newData);
                        }
                    });

                    console.log(`D3.js bar chart rendered for object ${objectId}`);
                } catch (error) {
                    console.error(`Error rendering D3.js bar chart for ${objectId}:`, error);
                    container.innerHTML = `
                        <div class="slds-card">
                            <div class="slds-card__body slds-card__body_inner">
                                <div class="slds-text-color_error">
                                    Erreur lors du rendu du graphique D3.js: ${error.message}
                                    <br><small>Vérifiez que la bibliothèque D3.js est chargée correctement.</small>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }

            // Fonction pour mettre à jour un graphique D3.js existant
            function updateD3BarChart(containerId, newData) {
                const chartRef = Object.keys(window).find(k => k.startsWith('d3Chart_') && window[k].chartContainer.id === containerId);
                if (!chartRef || !window[chartRef]) {
                    return;
                }
                
                const { svg, g, xScale, yScale, chartContainer } = window[chartRef];
                const width = chartContainer.clientWidth - 60 - 60;
                const height = 400 - 20 - 60;

                // Mettre à jour les échelles
                xScale.domain(newData.map(d => d.label));
                yScale.domain([0, d3.max(newData, d => d.value)]);

                // Mettre à jour les axes
                g.select('.x-axis').remove();
                g.select('.y-axis').remove();
                
                g.append('g')
                    .attr('class', 'x-axis')
                    .attr('transform', `translate(0,${height})`)
                    .call(d3.axisBottom(xScale))
                    .selectAll('text')
                    .attr('transform', 'rotate(-45)')
                    .style('text-anchor', 'end')
                    .style('font-size', '12px');

                g.append('g')
                    .attr('class', 'y-axis')
                    .call(d3.axisLeft(yScale))
                    .style('font-size', '12px');

                // Mettre à jour les barres
                const bars = g.selectAll('.bar')
                    .data(newData);

                bars.exit().remove();

                bars.enter()
                    .append('rect')
                    .attr('class', 'bar')
                    .merge(bars)
                    .transition()
                    .duration(500)
                    .attr('x', d => xScale(d.label))
                    .attr('y', d => yScale(d.value))
                    .attr('width', xScale.bandwidth())
                    .attr('height', d => height - yScale(d.value))
                    .attr('fill', '#0176d3');

                // Mettre à jour les labels
                const labels = g.selectAll('.bar-label')
                    .data(newData);

                labels.exit().remove();

                labels.enter()
                    .append('text')
                    .attr('class', 'bar-label')
                    .merge(labels)
                    .transition()
                    .duration(500)
                    .attr('x', d => xScale(d.label) + xScale.bandwidth() / 2)
                    .attr('y', d => yScale(d.value) - 5)
                    .text(d => d.value.toLocaleString());
            }

            function buildQueryParams(headers) {
                return Object.entries(headers)
                    .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
                    .join('&');
            }

            // Fonction principale pour se connecter avec enigma.js
            async function connectWithEnigma() {
                try {
                    // Attendre un peu pour que D3.js ait le temps de se charger
                    updateStatus('Attente du chargement de D3.js...');
                    await waitForD3();
                    
                    updateStatus('Connexion à Qlik avec enigma.js...');

                    const loggedIn = await qlikLogin();
                    if (!loggedIn) {
                        updateStatus('Redirection vers la page de connexion Qlik...', true);
                        return;
                    }

                    updateStatus('Récupération du token CSRF...');
                    const qcsHeaders = await getQCSHeaders();
                    const queryParams = buildQueryParams(qcsHeaders);
                    const identitySegment = QLIK_CLOUD_CONFIG.identity ? `/identity/${encodeURIComponent(QLIK_CLOUD_CONFIG.identity)}` : '';
                    const wsUrl = `wss://${QLIK_CLOUD_CONFIG.tenant}/app/${QLIK_CLOUD_CONFIG.appId}${identitySegment}?${queryParams}`;
                    
                    // Charger le schéma enigma.js
                    updateStatus('Chargement du schéma enigma.js...');
                    const schema = await fetch('https://unpkg.com/enigma.js@2.7.3/schemas/12.612.0.json')
                        .then(res => {
                            if (!res.ok) {
                                throw new Error(`Erreur lors du chargement du schéma: ${res.status}`);
                            }
                            return res.json();
                        });

                    // Créer la session enigma.js
                    // Pour le navigateur, on utilise WebSocket natif
                    // L'authentification se fait via les cookies de session créés par @qlik/embed-web-components
                    updateStatus('Création de la session enigma.js...');
                    const session = enigma.create({
                        schema: schema,
                        url: wsUrl
                    });

                    // Écouter les événements de trafic (optionnel, pour debug)
                    session.on('traffic:sent', (data) => console.log('enigma sent:', data));
                    session.on('traffic:received', (data) => console.log('enigma received:', data));
                    session.on('closed', () => console.log('enigma session closed'));

                    // Ouvrir la session
                    const global = await session.open();
                    updateStatus('Connecté à Qlik! Récupération des indicateurs...');

                    // Ouvrir le document (app)
                    const app = await global.openDoc(QLIK_CLOUD_CONFIG.appId);
                    updateStatus('Application ouverte. Récupération des données...');

                    const indicatorIds = prepareIndicatorContainers(QLIK_CLOUD_CONFIG.objectIds.length);

                    // Récupérer les indicateurs pour chaque objet
                    for (let i = 0; i < QLIK_CLOUD_CONFIG.objectIds.length; i++) {
                        const objectId = QLIK_CLOUD_CONFIG.objectIds[i];
                        try {
                            updateStatus(`Récupération de l'objet ${objectId}...`);
                            
                            const containerId = indicatorIds[i] || `indicator-${i}`;
                            
                            // Si c'est l'objet mrdwGJ, utiliser D3.js pour afficher un graphique en barre
                            if (objectId === 'mrdwGJ') {
                                updateStatus(`Rendu du graphique en barre D3.js pour ${objectId}...`);
                                await displayD3BarChart(containerId, app, objectId);
                            } else {
                                // Pour les autres objets, utiliser l'affichage standard
                                // Obtenir l'objet
                                const obj = await app.getObject(objectId);
                                
                                // Obtenir le layout avec les données
                                const layout = await obj.getLayout();
                                
                                // Afficher l'indicateur
                                displayIndicator(containerId, layout, objectId);
                                
                                // Écouter les changements
                                obj.on('changed', async () => {
                                    const updatedLayout = await obj.getLayout();
                                    displayIndicator(containerId, updatedLayout, objectId);
                                });
                            }
                            
                        } catch (error) {
                            console.error(`Error fetching object ${objectId}:`, error);
                            const containerId = indicatorIds[i] || `indicator-${i}`;
                            const container = document.getElementById(containerId);
                            if (container) {
                                container.innerHTML = `<div class="slds-text-color_error">Erreur: ${error.message}</div>`;
                            }
                        }
                    }

                    updateStatus('Indicateurs récupérés avec succès!');
                    
                    // Garder la session ouverte
                    window.qlikSession = session;
                    window.qlikApp = app;

                } catch (error) {
                    console.error('Error connecting with enigma.js:', error);
                    updateStatus(`Erreur de connexion: ${error.message}`, true);
                }
            }

            // Attendre que le script Qlik soit chargé avant de se connecter
            window.addEventListener('load', () => {
                // Attendre un peu pour que le token soit disponible
                setTimeout(() => {
                    connectWithEnigma();
                }, 2000);
            });
        </script>

        <style>
            .indicator-container {
                margin-bottom: 20px;
            }
            .slds-card {
                border: 1px solid #dddbda;
                border-radius: 4px;
            }
        </style>
    </head>

    <body>
        <div class="slds-scope">
            <div class="slds-page-header">
                <div class="slds-page-header__row">
                    <div class="slds-page-header__col-title">
                        <div class="slds-page-header__name">
                            <div class="slds-page-header__name-title">
                                <h1>
                                    <span class="slds-page-header__title">Qlik Enigma.js D3.js - Indicateurs</span>
                                </h1>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="slds-p-around_medium">
                <!-- Zone d'affichage des indicateurs (remplie dynamiquement) -->
                <div id="indicators-container"></div>

                <div class="slds-m-top_medium">
                    <div class="slds-text-heading_small">Status:</div>
                    <div id="status" class="slds-text-body_regular slds-text-color_success">
                        Initialisation de la connexion enigma.js...
                    </div>
                </div>
            </div>
        </div>
    </body>

    </html>
</apex:page>